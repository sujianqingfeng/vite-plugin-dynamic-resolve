#!/usr/bin/env node

'use strict';

const mri = require('mri');
const globby = require('globby');
const pathe = require('pathe');
const fsExtra = require('fs-extra');
const esbuild = require('esbuild');
const jiti = require('jiti');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      if (k !== 'default') {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    }
  }
  n["default"] = e;
  return Object.freeze(n);
}

const mri__default = /*#__PURE__*/_interopDefaultLegacy(mri);
const globby__default = /*#__PURE__*/_interopDefaultLegacy(globby);
const jiti__default = /*#__PURE__*/_interopDefaultLegacy(jiti);

const DECLARATION_RE = /\.d\.[cm]?ts$/;
const CM_LETTER_RE = /(?<=\.)(c|m)(?=[tj]s$)/;
const jsLoader = async (input, { options }) => {
  var _a, _b, _c;
  if (![".ts", ".js", ".cjs", ".mjs"].includes(input.extension) || input.path.match(DECLARATION_RE)) {
    return;
  }
  const output = [];
  let contents = await input.getContents();
  if (options.declaration && !((_a = input.srcPath) == null ? void 0 : _a.match(DECLARATION_RE))) {
    const cm = ((_c = (_b = input.srcPath) == null ? void 0 : _b.match(CM_LETTER_RE)) == null ? void 0 : _c[0]) || "";
    const extension = `.d.${cm}ts`;
    output.push({
      contents,
      srcPath: input.srcPath,
      path: input.path,
      extension,
      declaration: true
    });
  }
  if (input.extension === ".ts") {
    contents = await esbuild.transform(contents, { loader: "ts" }).then((r) => r.code);
  }
  const isCjs = options.format === "cjs";
  if (isCjs) {
    contents = jiti__default["default"]().transform({ source: contents, retainLines: false }).replace(/^exports.default = /mg, "module.exports = ");
  }
  output.push({
    contents,
    path: input.path,
    extension: options.ext ? `.${options.ext}` : isCjs ? ".js" : ".mjs"
  });
  return output;
};

const vueLoader = async (input, { loadFile }) => {
  if (input.extension !== ".vue") {
    return;
  }
  const contents = await input.getContents();
  const [scriptBlock, attrs = "", _lastAttr, script] = contents.match(/<script((\s[^>\s]*)*)>([\S\s.]*?)<\/script>/) || [];
  if (!scriptBlock || !script) {
    return;
  }
  if (attrs.split(/\s+/g).includes("setup")) {
    return;
  }
  const [, lang = "js"] = attrs.match(/lang="([a-z]*)"/) || [];
  const extension = "." + lang;
  const files = await loadFile({
    getContents: () => script,
    path: `${input.path}${extension}`,
    srcPath: `${input.srcPath}${extension}`,
    extension
  }) || [];
  const scriptFile = files.find((f) => [".js", ".mjs"].includes(f.extension));
  if (!scriptFile) {
    return;
  }
  const newAttrs = attrs.replace(new RegExp(`\\s?lang="${lang}"`), "");
  return [
    {
      path: input.path,
      contents: contents.replace(scriptBlock, `<script${newAttrs}>
${scriptFile.contents}<\/script>`)
    },
    ...files.filter((f) => f !== scriptFile)
  ];
};

const defaultLoaders = [vueLoader, jsLoader];
function createLoader(loaderOptions = {}) {
  const loaders = loaderOptions.loaders || defaultLoaders;
  const loadFile = async function(input) {
    const context = {
      loadFile,
      options: loaderOptions
    };
    for (const loader of loaders) {
      const outputs = await loader(input, context);
      if (outputs == null ? void 0 : outputs.length) {
        return outputs;
      }
    }
    return [
      {
        path: input.path,
        srcPath: input.srcPath,
        raw: true
      }
    ];
  };
  return {
    loadFile
  };
}

async function getDeclarations(vfs) {
  const ts = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('typescript')); });
  const inputFiles = [...vfs.keys()];
  const compilerOptions = {
    allowJs: true,
    declaration: true,
    incremental: true,
    skipLibCheck: true,
    emitDeclarationOnly: true
  };
  const tsHost = ts.createCompilerHost(compilerOptions);
  tsHost.writeFile = (fileName, declaration) => {
    vfs.set(fileName, declaration);
  };
  const _readFile = tsHost.readFile;
  tsHost.readFile = (filename) => {
    if (vfs.has(filename)) {
      return vfs.get(filename);
    }
    return _readFile(filename);
  };
  const program = ts.createProgram(inputFiles, compilerOptions, tsHost);
  await program.emit();
  const output = {};
  for (const filename of inputFiles) {
    const dtsFilename = filename.replace(/\.(m|c)?(ts|js)$/, ".d.$1ts");
    output[filename] = vfs.get(dtsFilename) || "";
  }
  return output;
}

async function mkdist(options = {}) {
  options.rootDir = pathe.resolve(process.cwd(), options.rootDir || ".");
  options.srcDir = pathe.resolve(options.rootDir, options.srcDir || "src");
  options.distDir = pathe.resolve(options.rootDir, options.distDir || "dist");
  if (options.cleanDist !== false) {
    await fsExtra.unlink(options.distDir).catch(() => {
    });
    await fsExtra.emptyDir(options.distDir);
    await fsExtra.mkdirp(options.distDir);
  }
  const filePaths = await globby__default["default"](options.pattern || "**", { absolute: false, cwd: options.srcDir });
  const files = filePaths.map((path) => {
    const srcPath = pathe.resolve(options.srcDir, path);
    return {
      path,
      srcPath,
      extension: pathe.extname(path),
      getContents: () => fsExtra.readFile(srcPath, { encoding: "utf8" })
    };
  });
  const { loadFile } = createLoader({
    format: options.format,
    ext: options.ext,
    declaration: options.declaration
  });
  const outputs = [];
  for (const file of files) {
    outputs.push(...await loadFile(file) || []);
  }
  for (const output of outputs.filter((o) => o.extension)) {
    const renamed = pathe.basename(output.path, pathe.extname(output.path)) + output.extension;
    output.path = pathe.join(pathe.dirname(output.path), renamed);
    if (outputs.find((o) => o !== output && o.path === output.path)) {
      output.skip = true;
    }
  }
  const dtsOutputs = outputs.filter((o) => o.declaration && !o.skip);
  if (dtsOutputs.length) {
    const declarations = await getDeclarations(new Map(dtsOutputs.map((o) => [o.srcPath, o.contents || ""])));
    for (const output of dtsOutputs) {
      output.contents = declarations[output.srcPath] || "";
    }
  }
  const outPaths = new Set(outputs.map((o) => o.path));
  const resolveExts = ["", "/index.mjs", "/index.js", ".mjs", ".ts"];
  const resolveId = (from, id = "") => {
    if (!id.startsWith(".")) {
      return id;
    }
    for (const ext of resolveExts) {
      if (outPaths.has(pathe.join(pathe.dirname(from), id + ext))) {
        return id + ext;
      }
    }
    return id;
  };
  for (const output of outputs.filter((o) => o.extension === ".mjs")) {
    output.contents = output.contents.replace(/(import|export)(.* from ['"])(.*)(['"])/g, (_, type, head, id, tail) => type + head + resolveId(output.path, id) + tail);
  }
  const writtenFiles = [];
  await Promise.all(outputs.filter((o) => !o.skip).map(async (output) => {
    const outFile = pathe.join(options.distDir, output.path);
    await fsExtra.mkdirp(pathe.dirname(outFile));
    if (output.raw) {
      await fsExtra.copyFile(output.srcPath, outFile);
    } else {
      await fsExtra.writeFile(outFile, output.contents, "utf8");
    }
    writtenFiles.push(outFile);
  }));
  return {
    writtenFiles
  };
}

async function main() {
  const args = mri__default["default"](process.argv.splice(2));
  if (args.help) {
    console.log("Usage: npx mkdist [rootDir] [--src=src] [--dist=dist] [--pattern=glob] [--format=cjs|esm] [-d|--declaration] [--ext=mjs|js|ts]");
    process.exit(0);
  }
  const { writtenFiles } = await mkdist({
    rootDir: args._[0],
    srcDir: args.src,
    distDir: args.dist,
    format: args.format,
    pattern: args.pattern,
    ext: args.ext,
    declaration: Boolean(args.declaration || args.d)
  });
  console.log(writtenFiles.map((f) => `- ${f}`).join("\n"));
  process.exit(0);
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});
